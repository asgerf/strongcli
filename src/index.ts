interface BaseOption {
    /**
     * Names of the option, such as `--foo-bar` or `-f`.
     *
     * Suppresses the default name generated by kebab-casing the property name.
     * Set `alias` instead to preserve the default name.
     */
    name?: string | string[];

    /**
     * Alternative name(s) of the option, such as `--foo-bar` or `-f`.
     *
     * Unlike `name`, setting this does not suppress the default name generated
     * by kebab-casing the property name.
     */
    alias?: string | string[];

    /**
     * Parser for the value given to this option, usually set to `String` or `Number`
     * -- should be omitted for options that don't take a value.
     *
     * The return type of this callback must be compatible with the corresponding interface type.
     *
     * If the callback throws a `ParseError`, it is shown nicely without a stack trace.
     */
    value?: (x: string) => any;

    /**
     * Description of this option to appear in the help.
     */
    description?: string;

    /**
     * Noun describing the value passed to the option.
     *
     * For example, setting this to `foo` causes the option to rendered as `--flag <foo>`
     * in the help.
     */
    valueHint?: string;

    /**
     * True if this option can be given multiple times.
     *
     * The corresponding interface type should be an array of the appropriate type.
     */
    repeatable?: boolean;

    /**
     * The value to use if this option was not present on the command-line.
     *
     * For repeatable options, the default value is used if the option was given zero times.
     * A shallow copy of the array is created, all other values are passed as they are.
     *
     * Set to `cli.required` if it is an error to omit the option.
     */
    default?: DefaultValue<any>;

    /**
     * Set to true if `NaN` values returned by the `value` callback should be allowed
     * -- otherwise they will be reported as errors.
     */
    allowNaN?: boolean;

    /**
     * Set to true if all following arguments up until the next one that begins with a dash ('-')
     * should be interpreted as values for this option. The corresponding interface type
     * should be an array.
     *
     * Set to the string `'all'` if _all_ remaining arguments should be consumed
     * even if they start with a dash ('-'), and it is not an error if zero arguments are passed.
     *
     * If the option is also repeatable, the corresponding interface type should be a nested
     * array. Each inner array represents one appearance of the option.
     *
     * If the value is set using `=`, for example, `--flag=VALUE`, only one value is consumed.
     *
     * ### Example
     * If using the configuration
     * ```typescript
     * { foo: { consumeMultipleArguments: true }, bar: {} }
     * ```
     * the command line `--foo x y z --bar` would be parsed as:
     * ```
     * { foo: ['x', 'y', 'z'], bar: true }
     * ```
     *
     * If `consumeMultipleArguments: 'all'` was used instead, it would be parsed as:
     * ```
     * { foo: ['x', 'y', 'z', '--bar'], bar: false }
     * ```
     */
    consumeMultipleArguments?: boolean | 'all';
}

type DefaultValue<T> = T | (() => T);

interface SingleValueOption<T> extends BaseOption {
    repeatable?: false;
    consumeMultipleArguments?: false;
    value: (x: string) => T;
    default?: DefaultValue<T>;
}
interface RequiredSingleValueOption<T> extends SingleValueOption<T> {
    default: DefaultValue<T>;
}

interface RepeatableOption<T> extends BaseOption {
    repeatable: true;
    consumeMultipleArguments?: false;
    value: (x: string) => T;
    default?: DefaultValue<T[]>;
}

interface MultiValueOption<T> extends BaseOption {
    repeatable?: false;
    consumeMultipleArguments: true | 'all';
    value: (x: string) => T;
    default?: DefaultValue<T[]>;
}

type ArrayValuedOption<T> = MultiValueOption<T> | RepeatableOption<T>;

interface NestedArrayValuedOption<T> extends BaseOption {
    repeatable: true;
    consumeMultipleArguments: true | 'all';
    value: (x: string) => T;
    default?: DefaultValue<T[][]>;
}

interface FlagOption extends BaseOption {
    repeatable?: false;
    consumeMultipleArguments?: false;
    value?: undefined;
    default?: boolean;
    valueHint?: undefined;
}

export type OptionalOption<T> =
    | SingleValueOption<T>
    | (T extends (infer R)[] ? ArrayValuedOption<R> : never)
    | (T extends (infer R)[][] ? NestedArrayValuedOption<R> : never)
    | (boolean extends T ? FlagOption : never)
    ;

export type RequiredOption<T> =
    | RequiredSingleValueOption<T>
    | (T extends (infer R)[] ? ArrayValuedOption<R> : never)
    | (T extends (infer R)[][] ? NestedArrayValuedOption<R> : never)
    | (boolean extends T ? FlagOption : never)
    ;

export type Option<T> =
    undefined extends T ? OptionalOption<T> : RequiredOption<T>;

export type OptionMap<T> = { [K in keyof T]: Option<T[K]> };

type ResultObj<T> = { [K in keyof T]: any };

/**
 * The result of parsing command-line options.
 */
export interface CommandLineArgs<T> {
    /** Options parsed from the command-line. */
    options: T;

    /** Positional arguments from the command-line. */
    args: string[];
}

/**
 * Settings of a CLI parser that aren't describing the options to be parsed.
 */
export interface CliParserSettings {
    /**
     * Name of the program to show in the usage help line.
     *
     * Defaults the basename of `process.argv[1]`.
     *
     * Has no effect if `usage` is also specified.
     */
    name?: string;

    /**
     * The usage line to show as part of the help.
     *
     * For example: `Usage: myprogram [--target FILE] FILES...`.
     */
    usage?: string;

    /**
     * Description of the program to show between usage-line and the
     * description of all the options.
     */
    description?: string | DescriptionPair;

    /**
     * Representation of positional arguments in the usage line.
     *
     * For example, setting this to `FILE` might generate the usage line:
     * ```txt
     * Usage: program [options] FILE
     * ```
     *
     * Has no effect if `usage` is also specified.
     */
    positionalArgHint?: string;

    /**
     * Show the help and exit if no arguments were provided.
     */
    helpIfEmpty?: boolean;

    /**
     * Whether to trim emply lines surrounding the usage string or description.
     * Defaults to true.
     *
     * Only empty lines are trimmed, indentation is preserved.
     */
    trimHelp?: boolean;
}

class OptionParserBuilder {
    constructor(public parserSettings: CliParserSettings) {}

    /**
     * Parse command-line arguments with given option specification.
     *
     * The type argument should refer to the desired parsed options.
     *
     * For example:
     * ```typescript
     * interface MyOptions {
     *   verbose: boolean;
     *   name: string;
     * }
     * let { options, args } = cli.program('foo').main<MyOptions>({
     *   verbose: {
     *     alias: '-v'
     *   },
     *   name: {
     *     value: String
     *   }
     * });
     * ```
     */
    public main<T>(options: OptionMap<T>) {
        return new OptionParser<T>(options, this.parserSettings).main();
    }

    /**
     * Create a CLI parser using the given option specification.
     *
     * The type argument should refer to the desired parsed options.
     *
     * For example:
     * ```typescript
     * interface MyOptions {
     *   verbose: boolean;
     *   name: string;
     * }
     * let parser = cli.program('my-program').parser<MyOptions>({
     *   verbose: {
     *     alias: '-v'
     *   },
     *   name: {
     *     value: String
     *   }
     * });
     * ```
     */
    public parser<T>(options: OptionMap<T>) {
        return new OptionParser<T>(options, this.parserSettings);
    }

    /**
     * Create a new CLI parser with subcommands.
     *
     * Call `.command()` for each command, and finally call `.main`.
     *
     * For example:
     * ```typescript
     *  export interface AddOptions {
     *      type: string;
     *      count: number;
     *  }
     *  program.command<AddOptions>({
     *      name: 'add',
     *      description: 'Adds new things',
     *      options: {
     *          type: {
     *              value: String
     *          },
     *          count: {
     *              value: Number
     *          }
     *      },
     *      callback(options, args) {
     *          console.log(`Adding ${options.count} of ${options.type} and also: ${args.join(', ')}`);
     *      },
     *  });
     * ```
     */
    public commandSet() {
        return new CommandSet(this.parserSettings);
    }
}

/**
 * Start creating an new CLI parser. Follow up with a call to `.parser()`.
 *
 * For example:
 * ```typescript
 * interface MyOptions {
 *   verbose: boolean;
 *   name: string;
 * }
 * let parser = cli.program('my-program').parser<MyOptions>({
 *   verbose: {
 *     alias: '-v'
 *   },
 *   name: {
 *     value: String
 *   }
 * });
 * ```
 */
export function program(settings: CliParserSettings | string) {
    if (typeof settings === 'string') {
        settings = { name: settings };
    }
    return new OptionParserBuilder(settings);
}

/**
 * Create a new CLI parser using the given option specification.
 *
 * The type argument should refer to the desired parsed options.
 *
 * For example:
 * ```typescript
 * interface MyOptions {
 *   verbose: boolean;
 *   name: string;
 * }
 * let parser = cli.parser<MyOptions>({
 *   verbose: {
 *     alias: '-v'
 *   },
 *   name: {
 *     value: String
 *   }
 * });
 * ```
 */
export function parser<T>(options: OptionMap<T>) {
    return new OptionParser<T>(options, undefined);
}

/**
 * Parse command-line arguments with given option specification.
 *
 * The type argument should refer to the desired parsed options.
 *
 * For example:
 * ```typescript
 * interface MyOptions {
 *   verbose: boolean;
 *   name: string;
 * }
 * let { options, args } = cli.main<MyOptions>({
 *   verbose: {
 *     alias: '-v'
 *   },
 *   name: {
 *     value: String
 *   }
 * });
 * ```
 */
export function main<T>(options: OptionMap<T>) {
    return parser(options).main();
}

/**
 * Create a new CLI parser with subcommands.
 *
 * Call `.command()` for each command, and finally call `.main`.
 *
 * For example:
 * ```typescript
 *  export interface AddOptions {
 *      type: string;
 *      count: number;
 *  }
 *  program.command<AddOptions>({
 *      name: 'add',
 *      description: 'Adds new things',
 *      options: {
 *          type: {
 *              value: String
 *          },
 *          count: {
 *              value: Number
 *          }
 *      },
 *      callback(options, args) {
 *          console.log(`Adding ${options.count} of ${options.type} and also: ${args.join(', ')}`);
 *      },
 *  });
 * ```
 */
export function commandSet(settings: CliParserSettings | string) {
    return program(settings).commandSet();
}

/**
 * A CLI option parser, usually created using `cli.parser()` or `cli.program().parser()`.
 */
export class OptionParser<T> {
    private readonly shortCharToName = new Map<string, keyof T>();
    private readonly longOptionToName = new Map<string, keyof T>();
    private readonly optionKeys: (keyof T & string)[];
    private readonly parserSettings: CliParserSettings;

    /**
     * Creates a new CLI option parser directly.
     *
     * This is usually not called directly, instead prefer `cli.parser` or `cli.program().parser()`.
     */
    constructor(public options: OptionMap<T>, parserSettings?: CliParserSettings, private readonly outerProgramName?: string) {
        this.parserSettings = parserSettings || {};
        let { shortCharToName, longOptionToName } = this;
        this.optionKeys = Object.keys(options) as any;
        let plainObj = {};
        for (let key of this.optionKeys) {
            if (key in plainObj) {
                throw new Error(`The key ${key} clashes with a built-in property.`);
            }
            let option = options[key];
            let names = this.getNamesFromOption(option, key);
            for (let name of names) {
                if (name.startsWith('--')) {
                    if (name.length < 3) {
                        throw new Error(`Invalid long option ${name}: Long options must be of form "--xxx".`);
                    }
                    if (longOptionToName.has(name)) {
                        throw new Error(`Duplicate option ${name}: used by both ${key} and ${longOptionToName.get(name)}.`);
                    }
                    longOptionToName.set(name, key);
                } else if (name.startsWith('-')) {
                    if (name.length !== 2) {
                        throw new Error(`Invalid short option ${name}: Short options must be of form "-x"'.`);
                    }
                    let shortChar = name.charAt(1);
                    if (shortCharToName.has(shortChar)) {
                        throw new Error(`Duplicate short option ${name}: used by both ${key} and ${shortCharToName.get(shortChar)}.`);
                    }
                    shortCharToName.set(shortChar, key);
                } else {
                    throw new Error(`Invalid name ${name}. Must be of form "--xxx" or "-x"`);
                }
            }
        }
    }

    private getNamesFromOption(option: BaseOption, key: string): string[] {
        let names = [...asArray(option.name), ...asArray(option.alias)];
        if (option.name === undefined) {
            names.push('--' + camelToKebabCase(key));
        }
        return names;
    }

    /**
     * Parses the given command-line arguments and returns the parsed options.
     *
     * The argument list should *not* include the first two entries of `process.argv`.
     * If the argument list is omitted, `process.argv.slice(2)` is used.
     *
     * If an exception is thrown, the error is written to stderr without a stack trace, and
     * the program exits with exit code 1. To handle errors yourself, call `parse` instead
     * of `main`.
     */
    public main(args?: string[]): CommandLineArgs<T> {
        try {
            args = args || process.argv.slice(2);
            if (args.length === 0 && this.parserSettings.helpIfEmpty) {
                this.help();
            }
            return this.parse(args || process.argv.slice(2));
        } catch (e) {
            console.error(e instanceof ParseError ? e.toString() : e);
            process.exit(1);
        }
    }

    private getValueHint(fn: ((x: string) => any) & { hint?: string }) {
        if (fn === Number || fn === parseInt || fn === parseFloat) {
            return 'num';
        }
        if (fn.hint) {
            return fn.hint;
        }
        return 'value';
    }

    /**
     * Returns the program usage help.
     */
    public getHelp() {
        let { parserSettings: { positionalArgHint, description, usage, name } } = this;
        if (usage == null) {
            positionalArgHint = positionalArgHint == null ? '' : ` ${positionalArgHint}`;
            if (name == null) {
                name = require('path').basename(process.argv[1]);
            }
            let { outerProgramName } = this;
            if (outerProgramName != null) {
                name = outerProgramName + ' ' + name;
            }
            usage = `Usage: ${name} [options]${positionalArgHint}`;
        } else {
            usage = this.trimHelp(usage);
        }
        description = description == null ? '' : `${this.trimHelp(getLongDescription(description))}\n\n`;
        let optionHelp = this.getOptionHelp(4);
        return `\n${usage}\n\n${description}${optionHelp}`;
    }

    /**
     * Prints the program help text and exits.
     */
    public help(): never {
        console.error(this.getHelp());
        process.exit(1);
    }

    /**
     * Returns the help generated from all options in the program, with
     * the given indentation.
     *
     * This is included in `getHelp()` but may be useful for constructing your
     * own help string.
     */
    public getOptionHelp(indentation: number) {
        let { options, optionKeys } = this;
        let result = 'Options:\n';
        let flagColumn = [];
        let flagColumnWidth = 20;
        for (let key of optionKeys) {
            let option = options[key];
            let names = this.getNamesFromOption(option, key).join(', ');
            if (option.valueHint) {
                names += ` <${option.valueHint}>`;
            } else if (option.value) {
                let hint = this.getValueHint(option.value);
                names += ` <${hint}>`;
            }
            flagColumn.push(names);
            if (names.length > flagColumnWidth) {
                flagColumnWidth = names.length;
            }
        }
        ++flagColumnWidth; // Leave one space
        let baseIndent = padRight('', indentation);
        let descriptionIndent = padRight('', flagColumnWidth + indentation);
        for (let i = 0; i < flagColumn.length; ++i) {
            let option = options[optionKeys[i]];
            let descriptionLines = this.trimHelp(option.description || '').split(/\n/);
            result += baseIndent + padRight(flagColumn[i], flagColumnWidth) + descriptionLines[0] + '\n';
            for (let j = 1; j < descriptionLines.length; ++j) {
                result += descriptionIndent + descriptionLines[j] + '\n';
            }
        }
        return result;
    }

    /**
     * Trims empty lines around the given string unless disabled by `trimHelp: false`.
     */
    private trimHelp(str: string) {
        return this.parserSettings.trimHelp === false
            ? str
            : trimLines(str);
    }

    /**
     * Parses the given argument list and returns the parsed options.
     *
     * The argument list should *not* include the first two entries of `process.argv`.
     *
     * In case invalid options are passed in, a `ParseError` is thrown.
     */
    public parse(argumentList: string[]): CommandLineArgs<T> {
        let { options, optionKeys, longOptionToName, shortCharToName } = this;
        let optionArgs = {} as ResultObj<T>;
        let positionalArgs = [];
        let seenOptions = new Set<string>();
        // Initialize arrays and flags.
        for (let key of optionKeys) {
            let option = options[key];
            if (option.repeatable || option.consumeMultipleArguments) {
                optionArgs[key] = [] as any;
            } else if (!option.value) {
                optionArgs[key] = false;
            }
        }
        for (let i = 0; i < argumentList.length; ++i) {
            let arg = argumentList[i];
            if (!arg.startsWith('-')) {
                positionalArgs.push(arg);
                continue;
            }
            let flag = arg;
            let valueStr: string | undefined = undefined;
            let equalsIndex = flag.indexOf('=');
            if (equalsIndex !== -1) {
                valueStr = flag.substring(equalsIndex + 1);
                flag = flag.substring(0, equalsIndex);
            }
            let optionName: keyof T | undefined;
            if (flag.startsWith('--')) {
                if (flag.length === 2) {
                    positionalArgs.push(...argumentList.slice(i + 1));
                    break;
                }
                optionName = longOptionToName.get(flag);
                if (optionName == null) {
                    this.fail(arg, `Unrecognized option '${flag}'`);
                }
            } else {
                if (equalsIndex !== -1 && flag.length > 2) {
                    this.fail(arg, `Combined short arguments may not use '='. Use long-form version or omit the '='.`);
                }
                for (let charIndex = 1; charIndex < flag.length; ++charIndex) {
                    let char = flag.charAt(charIndex);
                    optionName = shortCharToName.get(char);
                    if (optionName === undefined) {
                        this.fail(arg, `Unrecognized short option '-${char}'`);
                    }
                    let option = options[optionName];
                    if (option.value) {
                        if (valueStr === undefined && charIndex < flag.length - 1) {
                            valueStr = flag.substring(charIndex + 1);
                        }
                        break;
                    } else {
                        optionArgs[optionName] = true;
                    }
                }
                if (optionName === undefined) { // Happens if argument was just a `-`
                    this.fail(arg, 'Incomplete argument.');
                }
            }
            let option = options[optionName];
            if (option.value) {
                if (valueStr === undefined && i < argumentList.length - 1 && !argumentList[i + 1].startsWith('-')) {
                    valueStr = argumentList[++i];
                    arg += ' ' + valueStr;
                }
                if (valueStr === undefined && option.consumeMultipleArguments === 'all') {
                    continue; // Does not need to consume any values.
                }
                if (valueStr === undefined) {
                    this.fail(arg, `This option takes value.`);
                }
                let value = this.parseValue(arg, valueStr, option.value, option.allowNaN);
                if (option.consumeMultipleArguments) {
                    value = [value];
                    if (equalsIndex === -1) {
                        let stopAtDash = option.consumeMultipleArguments !== 'all';
                        while (i < argumentList.length - 1 && !(stopAtDash && argumentList[i + 1].startsWith('-'))) {
                            let nextArg = argumentList[++i];
                            value.push(this.parseValue(flag + ' ' + nextArg, nextArg, option.value, option.allowNaN));
                        }
                    }
                }
                if (option.repeatable) {
                    optionArgs[optionName].push(value);
                } else if (seenOptions.has(optionName as string)) {
                    this.fail(arg, `This option is not repeatable.`);
                } else {
                    optionArgs[optionName] = value;
                }
            } else {
                optionArgs[optionName] = true;
            }
            seenOptions.add(optionName as string);
        }
        // Fill in defaults for omitted values. Do this last so they're not confused with repeated values.
        for (let key of optionKeys) {
            let option = options[key];
            if (!hasOwnProp(option, 'default') || seenOptions.has(key)) {
                continue;
            }
            let defaultValue = option.default;
            if (defaultValue === required) {
                let names = this.getNamesFromOption(option, key);
                let name = names.find(x => x.startsWith('--')) || names[0] || key;
                this.fail(name, 'This option is required.');
            }
            if (typeof defaultValue === 'function') {
                defaultValue = (defaultValue as DefaultValue<any>)();
            }
            if (option.repeatable || option.consumeMultipleArguments) {
                optionArgs[key] = [...defaultValue as any[]];
            } else if (!hasOwnProp(optionArgs, key)) {
                optionArgs[key] = defaultValue;
            }
        }
        return {
            options: optionArgs,
            args: positionalArgs
        };
    }

    private parseValue(arg: string, valueStr: string, fn: (x: string) => any, allowNaN: boolean | undefined) {
        let value: any;
        try {
            value = fn(valueStr);
        } catch (e) {
            if (e instanceof ParseError) {
                e.argument = arg;
            }
            throw e;
        }
        if (!allowNaN && value !== value) {
            let message = `Unexpected value '${valueStr}'.`;
            if (fn === Number || fn === parseInt) {
                message += ' This option takes a numeric value.';
            }
            this.fail(arg, message);
        }
        return value;
    }

    private fail(arg: string, message: string): never {
        throw new ParseError(message, arg);
    }
}

/**
 * Exception that can be thrown by the `value` function of an option to indicate
 * that an error should be displayed for that option.
 */
export class ParseError {
    constructor(public message: string, public argument?: string | undefined) {}

    public toString() {
        let { argument, message } = this;
        return argument === undefined ? message : (argument + ': ' + message);
    }
}

/**
 * Similar to `Number` except only integers are allowed.
 *
 * Throws a `ParseError` if the value could not be parsed as an integer.
 */
export function integer(x: string): number {
    let value = Number(x);
    if ((value | 0) !== value) {
        throw new ParseError(`Unexpected value '${x}'. This option takes an integer.`);
    }
    return value;
}

function asArray<T>(x: T | T[] | undefined | null): T[] {
    if (x == null) {
        return [];
    }
    if (Array.isArray(x)) {
        return x;
    }
    return [x];
}

function hasOwnProp(obj: object, prop: string) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

function camelToKebabCase(str: string) {
    return str.replace(/[a-z][A-Z]|[A-Z]{2}[a-z]/g, x => x.charAt(0) + '-' + x.substring(1)).toLowerCase();
}

function padRight(str: string, len: number) {
    while (str.length < len) {
        str += ' ';
    }
    return str;
}

export interface DescriptionPair {
    /**
     * Short description to show in overview of commands.
     */
    brief: string;

    /**
     * Long description to show in the help page for this command.
     */
    long: string;
}

export interface CommandSettings<T> extends CliParserSettings {
    /**
     * Name of the command to add.
     */
    name: string;
    description?: string | DescriptionPair;

    /**
     * Command-line options accepted by this command.
     */
    options: OptionMap<T>;

    /**
     * Function to be invoke when executing the command.
     *
     * Such a callback is invoked when calling `commandSet.main()` or `commandSet.execute()`.
     */
    callback(this: undefined, options: T, args: string[]): void;
}

/**
 * The result of parsing a command and its options.
 */
export interface ParsedCommand extends CommandLineArgs<any> {
    command: string;
}

export class CommandSet {
    private settings: CliParserSettings;
    private commands = new Map<string, CommandSettings<any>>();
    private commandParsers = new Map<string, OptionParser<any>>();

    constructor(settings: CliParserSettings) {
        this.settings = settings || {};

        this.command({
            name: 'help',
            description: 'Show help for a command',
            positionalArgHint: '<cmd>',
            options: {},
            callback: this.helpCommand.bind(this)
        });
    }

    /**
     * Adds a new command to the command set.
     *
     * For example:
     * ```typescript
     *  export interface AddOptions {
     *      type: string;
     *      count: number;
     *  }
     *  program.command<AddOptions>({
     *      name: 'add',
     *      description: 'Adds new things',
     *      options: {
     *          type: {
     *              value: String
     *          },
     *          count: {
     *              value: Number
     *          }
     *      },
     *      callback(options, args) {
     *          console.log(`Adding ${options.count} of ${options.type} and also: ${args.join(', ')}`);
     *      },
     *  });
     * ```
     */
    public command<T>(settings: CommandSettings<T>): void {
        let { commands, commandParsers } = this;
        let { name } = settings;
        if (commands.has(name)) {
            throw new Error(`Duplicate command '${name}'`);
        }
        commandParsers.set(name, new OptionParser(settings.options, settings, this.settings.name));
        commands.set(name, settings);
    }

    /**
     * Parses the given command-line arguments and executes its callback function/
     *
     * The argument list should *not* include the first two entries of `process.argv`.
     * If the argument list is omitted, `process.argv.slice(2)` is used.
     *
     * If an exception is thrown, the error is written to stderr without a stack trace, and
     * the program exits with exit code 1. To handle errors yourself, call `parse` instead
     * of `main`.
     */
    public main(args?: string[]) {
        if (args == null) {
            args = process.argv.slice(2);
        }
        if (args.length === 0) {
            this.help();
        }
        let command = args[0];
        let optionParser = this.commandParsers.get(command)!;
        if (optionParser == null) {
            throw new ParseError(`Unrecognized command '${command}'`);
        }
        let parsedCommand = optionParser.main(args.slice(1));
        this.commands.get(command)!.callback.call(undefined, parsedCommand.options, parsedCommand.args);
    }

    /**
     * Parses the given argument list and returns the command and its parsed options.
     *
     * The argument list should *not* include the first two entries of `process.argv`.
     *
     * In case invalid options are passed in, a `ParseError` is thrown.
     */
    public parse(args: string[]): ParsedCommand {
        if (args.length === 0) {
            throw new ParseError('No command was given');
        }
        let command = args[0];
        let optionParser = this.commandParsers.get(command)!;
        if (optionParser == null) {
            throw new ParseError(`Unrecognized command '${command}'`);
        }
        let result = optionParser.parse(args.slice(1)) as ParsedCommand;
        result.command = command;
        return result;
    }

    /**
     * Parses the given command and executes its callback function.
     *
     * Unlike `main`, this will not write to the console or call `process.exit`.
     */
    public execute(args: string[]): ParsedCommand {
        let parsedCommand = this.parse(args);
        this.commands.get(parsedCommand.command)!.callback.call(undefined, parsedCommand.options, parsedCommand.args);
        return parsedCommand;
    }

    /**
     * Prints the program help text and exits.
     */
    public help(): never {
        console.error(this.getHelp());
        process.exit(1);
    }

    /** Returns the usage string and list of command names. */
    public getHelp(): string {
        let { settings: { description, usage, name } } = this;
        if (usage == null) {
            if (name == null) {
                name = require('path').basename(process.argv[1]);
            }
            usage = `Usage: ${name} command [<args>]`;
        }
        description = description == null ? '' : `${description}\n\n`;
        let commandHelp = this.getCommandOverview(4);
        return `\n${usage}\n\n${description}${commandHelp}`;
    }

    /** Returns the list of subcommands. */
    public getCommands() {
        return Array.from(this.commands.keys());
    }

    /** Returns the parser for the given subcommand. */
    public getSubcommand(command: string): OptionParser<any> {
        let optionParser = this.commandParsers.get(command);
        if (optionParser == null) {
            throw new Error(`Unrecognized command: ${command}`);
        }
        return optionParser;
    }

    private getCommandOverview(indentation: number) {
        let result = 'Commands:\n';
        let verbs = Array.from(this.commands).map(([name, cmd]) => {
            if (cmd.positionalArgHint != null) {
                name += ' ' + cmd.positionalArgHint;
            }
            return name;
        });
        let commandWidth = 4 + Math.max(8, ...verbs.map(x => x.length));
        let indent = padRight('', indentation);
        let index = 0;
        this.commands.forEach(commandParser => {
            let name = verbs[index++];
            result += indent + padRight(name, commandWidth) + getBriefDescription(commandParser.description) + '\n';
        });
        return result;
    }

    private helpCommand(options: {}, args: string[]) {
        if (args.length === 0) {
            this.help();
        }
        let command = args[0];
        let optionParser = this.commandParsers.get(command);
        if (optionParser == null) {
            console.error(`Unrecognized command: '${command}'`);
            process.exit(1);
        }
        optionParser.help();
    }
}

function getBriefDescription(description: null | undefined | string | DescriptionPair) {
    if (description == null) {
        return '';
    } else if (typeof description === 'string') {
        let eol = description.search(/\r|\n/);
        return eol === -1 ? description : description.substring(0, eol);
    } else {
        return description.brief;
    }
}

function getLongDescription(description: null | undefined | string | DescriptionPair) {
    if (description == null) {
        return '';
    } else if (typeof description === 'string') {
        return description;
    } else {
        return description.long;
    }
}

function trimLines(str: string) {
    return str.trimRight().replace(/^\s+(?<=[\r\n])/, '');
}

/**
 * Use as the `default` value to mark an option as required.
 *
 * For example:
 * ```typescript
 * interface Options {
 *   foo: number;
 * }
 * cli.main<Options>{
 *   foo: {
 *     value: Number,
 *     default: cli.required // note: do not call cli.required()
 *   }
 * }
 * ```
 *
 * Specifically, this function immediately throws a `ParseError` with the message "This option is required".
 */
export function required(): never {
    throw new Error('Do not call this function. Just set it to the default.');
}
